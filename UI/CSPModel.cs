using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using PAT.Common;
using OutOfMemoryException = PAT.Common.Classes.Expressions.ExpressionClass.OutOfMemoryException;
using PAT.Common.Classes.Expressions.ExpressionClass;
using PAT.Common.Classes.ModuleInterface;
using System.Text.RegularExpressions;
using System.Reflection;

namespace UI
{
	class CSPModel
	{
		List<string> channels;
		HashSet<string> allMessages;
		List<string> constantMessages;
		List<string> intMessages;
		string[] simpleModelLines;
		string fullModelPath;
		List<string> updatedSimpleModelLines;
		int maxMessageInOneLine = 0;
		List<string> variablListForFullModelAttackers;
		List<string> assertionListForFullModelAttackers;
		List<string> securityPropertyListForFullModelAttackers;
		List<string> attackProcesses;


		const string LIB_NAME = "Lib_HomeScan.dll";
		const string CHANNEL = "channel";
		const string ATTACKER_PROCESS = "AutoGeneratedNetworkAttacker()";
		const string ATTACKER_KNOWLEDGE_VARIABLE_NAME = "AutoGeneratedAttackerKnowledge";


		public CSPModel(string inputFile, string outputFile)
		{
			channels = new List<string>();
			allMessages = new HashSet<string>();
			constantMessages = new List<string>();
			intMessages = new List<string>();
			simpleModelLines = File.ReadAllLines(inputFile);
			fullModelPath = outputFile;
			updatedSimpleModelLines = new List<string>();
			variablListForFullModelAttackers = new List<string>();
			assertionListForFullModelAttackers = new List<string>();
			securityPropertyListForFullModelAttackers = new List<string>();
			attackProcesses = new List<string>();
		}

		// the full model is input to this method 
		private bool AnalyzeModel(string mainProcessName)
		{
			List<string> simpleModelList = new List<string>();

			int attackerAddedCounter = 0;
			//Go throught the full model line by line
			string tempLine = "";
			bool tempUsing = false;
			for (int i = 0; i < simpleModelLines.Length; i++)
			{
				// remove comments and leading and trailing white-space
				string line = simpleModelLines[i];
				int commentIndex = line.IndexOf("//");
				if (commentIndex >= 0)
				{
					line = line.Substring(0, commentIndex);
				}
				line = line.Trim();

				//If not end with ";" then append next line, and increase the line count by 1
				if (!line.Contains(";"))
				{
					tempLine = tempLine + line;
					tempUsing = true;
					continue;
				}
				else
				{
					// append the line with ; at the end
					if (tempUsing)
					{
						tempLine = tempLine + line;
						line = tempLine;
						tempLine = "";
						tempUsing = false;
					}
				}


				//Console.WriteLine(line);
				updatedSimpleModelLines.Add(line);

				// handle mulptile statement in a line sperated by ';'
				string[] multiStatements = line.Split(new string[] { ";" }, StringSplitOptions.RemoveEmptyEntries);
				foreach (string stat in multiStatements)
				{

					string statement = stat.Trim();
					simpleModelList.Add(statement);

					// Prepare the List<> variablListForFullModelAttackers  to be added in the fullmodel
					//if (stat.StartsWith("enum"))
					//{
					//	string[] tokens = line.Split(new string[] { "{", "}" }, StringSplitOptions.RemoveEmptyEntries);
					//	if (tokens.Length > 1)
					//	{
					//		string[] tokens_values = tokens[1].Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);
					//		foreach (var item in tokens_values)
					//		{
					//			string varName = "att" + item.Trim().ToLowerInvariant();
					//			string newVar = "var " + varName + " = -1;";
					//			variablListForFullModelAttackers.Add(newVar);
					//		}
					//	}
					//}

					// To  use for the GeneralAttacker generation
					// check the number of message parameters in one line i) between (!,->) or (?, ->), or (->, ->)
					var betweenValue = Regex.Match(statement, "!(.*)->").Groups[1].Value; // between value (Groups[0].Value;// with ! and ->)

					string[] betweenValueWithoutArrow = betweenValue.Split(new string[] { "->" }, StringSplitOptions.RemoveEmptyEntries);
					foreach (String v in betweenValueWithoutArrow)
					{
						//line spearated by "."
						string[] maxSizeCheck = v.Split(new string[] { "." }, StringSplitOptions.RemoveEmptyEntries);
						if (maxSizeCheck.Length > maxMessageInOneLine)
						{
							maxMessageInOneLine = maxSizeCheck.Length;
						}
					}
					//Add the Attacker process to the Main Process
					if (statement.StartsWith(mainProcessName))
					{
						int equalIndex = statement.IndexOf("=");
						if (equalIndex > 0)
						{
							//check if this statement defines the main process
							if (statement.Substring(0, equalIndex).Split(new string[] { " ", mainProcessName }, StringSplitOptions.RemoveEmptyEntries).Length == 0)
							{
								string searchString = statement.Substring(0, equalIndex + 1); // string from mainProcessName to equal sign
								string fullLine = simpleModelLines[i];
								int searchIndex = fullLine.IndexOf(searchString);

								if (searchIndex >= 0 && (searchIndex < commentIndex || commentIndex < 0))
								{
									int breakingIndex = searchIndex + searchString.Length; // break line at index of equal sign + 1
									int sizeOfUpdatedModel = updatedSimpleModelLines.Count();
									if (fullLine.Contains("|||"))
									{
										updatedSimpleModelLines[sizeOfUpdatedModel - 1] = fullLine.Substring(0, breakingIndex) + ATTACKER_PROCESS + " |||" + fullLine.Substring(breakingIndex);
									}
									else
									{
										updatedSimpleModelLines[sizeOfUpdatedModel - 1] = fullLine.Substring(0, breakingIndex) + ATTACKER_PROCESS + " ||" + fullLine.Substring(breakingIndex);

									}
									attackerAddedCounter++;
								}

								////////////////////////////////////////////////////////////////////
								///// Add several processes to use with assertions
								string processSeq = statement.Replace(searchString, "");
								if (fullLine.Contains("|||"))
								{
									string[] processList = processSeq.Split(new string[] { "|||" }, StringSplitOptions.None);
									// generate three submain processes
									//attackProcesses.Add();
									addMaliciousProceses(processList, "|||");
								}
								else
								{
									string[] processList = processSeq.Split(new string[] { "||" }, StringSplitOptions.None);
									// generate three submain processes
									addMaliciousProceses(processList, "||");
								}
								////////////////////////////////////////////////////////////////////
							}
						}
					}
				}
			}

			if (attackerAddedCounter != 1)
			{
				string errMsg = ATTACKER_PROCESS + " is appended as a parallel process " + attackerAddedCounter + " time(s)! Expected 1 time exactly!\nYou may provided a wrong main process name! Stop Processing!";
				//Debug.Assert(false, errMsg);
				System.Windows.MessageBox.Show(errMsg);
				return false;
			}

			// load the cryptographic primitive library to get the unittype type list
			// load it in a separate domain, so that later pat module can still load it to verify csp model
			AppDomain getUnitypeTypeListDomain = AppDomain.CreateDomain("GetUnitypeTypeListDomain");
			Console.WriteLine("TEST !!!!!!!!!!!!!!!!!!!!!!!!!!!!");
			Console.WriteLine(getUnitypeTypeListDomain);
			Type type = typeof(GetTypeListProxy);
			GetTypeListProxy getTypeListProxy = (GetTypeListProxy)getUnitypeTypeListDomain.CreateInstanceAndUnwrap(
				type.Assembly.FullName,
				type.FullName);

			HashSet<string> typeList = getTypeListProxy.GetUnitypeTypeList(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Lib", LIB_NAME));
			Console.WriteLine("TEST !!!!!!" + Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Lib", LIB_NAME));
			Console.WriteLine("TEST !!!!!!" + typeList);
			AppDomain.Unload(getUnitypeTypeListDomain);

			foreach (string line in simpleModelList)
			{
				if (line.StartsWith(CHANNEL))
				{
					string[] tokens = line.Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);
					if (tokens[0].Equals(CHANNEL) && tokens.Length > 1)
					{
						channels.Add(tokens[1]);
					}
				}
				else if (line.StartsWith("var<")) // global variable
				{
					string[] tokens = line.Split(new string[] { " ", ";", "=" }, StringSplitOptions.RemoveEmptyEntries);
					if (tokens.Length > 1)
					{
						// the first element is the type declaration
						// the second element is the variable name
						string typeName = Regex.Match(tokens[0], @"<([^>]*)>").Groups[1].Value;
						if (typeName.Equals("Constant"))
						{
							constantMessages.Add(tokens[1]);
							Console.WriteLine("TEST CSPModel.cs analyzeModel() !!!!!! " + tokens[1]);
						}
						else if (typeList.Contains(typeName))
						{
							allMessages.Add(tokens[1]);
						}
					}
				}
				else if (line.StartsWith("enum"))
				{
					string[] tokens = line.Split(new string[] { "{", "}" }, StringSplitOptions.RemoveEmptyEntries);
					foreach (var item in tokens)
					{
						Console.WriteLine(item.ToString());
					}
					if (tokens.Length > 1)
					{
						string[] tokens_values = tokens[1].Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);

						foreach (var item in tokens_values)
						{
							// Console.WriteLine(item.ToString());
						}
						if (tokens_values.Length > 1)
						{
							foreach (var item in tokens_values)
							{
								intMessages.Add(item);
								// Console.WriteLine("TEST CSPModel.cs analyzeModel() !!!!!!" + item.ToString());
							}

						}
					}
				}
			}
			return true;
			/////////////// END AnalyzeModel()
		}


		public void addMaliciousProceses(string[] processList, string type)
		{
			foreach (string process in processList)
			{
				MatchCollection nameP = Regex.Matches(process, "[SD|CP|GS|HS|ZFE](.*)");
				foreach (Match n in nameP)
				{
					var x = Regex.Replace(n.Value, "^SD", "MaliciousSDSystem");
					var y = Regex.Replace(x, "^CP", "MaliciousCPSystem");
					var p = Regex.Replace(y, "^ZFE", "MaliciousZFESystem");
					var q = Regex.Replace(p, "^HS", "MaliciousHSSystem");
					var z = Regex.Replace(q, "^GS", "MaliciousGSSystem");
					string name = z.Split('(')[0];
					string submainProcess = name + "=";
					int c = 1;
					foreach (string process2 in processList)
					{
						if (c != 1)
						{
							submainProcess = submainProcess + type;
						}
						if (process2.Trim().Equals(n.Value.Trim()))
						{
							var xx = Regex.Replace(process2.Trim(), "^SD", "MaliciousSD");
							var yy = Regex.Replace(xx, "^CP", "MaliciousCP");
							var pp = Regex.Replace(yy, "^ZFE", "MaliciousZFE");
							var qq = Regex.Replace(pp, "^HS", "MaliciousHS");
							var zz = Regex.Replace(qq, "^GS", "MaliciousGS");
							submainProcess = submainProcess + zz;
						}
						else
						{
							submainProcess = submainProcess + process2.Trim();
						}

						if (c == processList.Length)
						{
							submainProcess = submainProcess + ";";
						}
						c++;

					}
					Console.WriteLine(submainProcess);
					attackProcesses.Add(submainProcess);
				}
			}
		}

		public bool ToFullModel(string mainProcessName)
		{
			if (!AnalyzeModel(mainProcessName))
				return false;

			List<string> fullModelLines = new List<string>();
			List<string> netAttackerModelLines = new List<string>();
			List<string> newfullModelLines = new List<string>();
			fullModelLines.AddRange(updatedSimpleModelLines);

			//////////////////////////////////////////////////////////////////////////
			// Add malicious attackers for each participant CP or SD in the model
			foreach (String stat in updatedSimpleModelLines)
			{
				//each stat ends in ";" and single process or var etc in each statement
				// Find processe names with "()" 
				// Replace each process with a similar attacker process => only change the name of the process
				if (stat.Contains("()") | stat.Contains("("))
				{
					//First extracts process names => ens with () or (); not contain (-> ! ? . = ())

					//stat = stat.Replace("","");
					//fullModelLines.Add(stat);
					MatchCollection pattern1 = Regex.Matches(stat, "[^ =>?.('\\])'[-]([a-z-A-Z-0-9_]+?)[(]?[a-z-A-Z-0-9, _]+[)]"); //CPPar(numcps)
					MatchCollection pattern2 = Regex.Matches(stat, "[^ =>?.('\\])'[-]([a-z-A-Z-0-9_]+?)[(][)]");// SDBroadcastWiFiBeacon()
					var updatedStat = stat;
					foreach (Match m in pattern1)
					{
						MatchCollection nameP = Regex.Matches(m.Value, "[SD|CP|GS|ZFE|HS](.*)");

						foreach (Match n in nameP)
						{
							var x = Regex.Replace(n.Value, "^SD", "MaliciousSD");
							var y = Regex.Replace(x, "^CP", "MaliciousCP");
							var p = Regex.Replace(y, "^ZFE", "MaliciousZFE");
							var q = Regex.Replace(p, "^HS", "MaliciousHS");
							var z = Regex.Replace(q, "^GS", "MaliciousGS");
							updatedStat = updatedStat.Replace(n.Value, z);
						}
					}
					foreach (Match m in pattern2)
					{
						MatchCollection nameP = Regex.Matches(m.Value, "[SD|CP|GS|ZFE|HS](.*)");
						foreach (Match n in nameP)
						{
							var x = Regex.Replace(n.Value, "^SD", "MaliciousSD");
							var y = Regex.Replace(x, "^CP", "MaliciousCP");
							var p = Regex.Replace(y, "^ZFE", "MaliciousZFE");
							var q = Regex.Replace(p, "^HS", "MaliciousHS");
							var z = Regex.Replace(q, "^GS", "MaliciousGS");
							updatedStat = updatedStat.Replace(n.Value, z);
						}
					}

					updatedStat = updatedStat.Replace("MaliciousMaliciousMalicious", "Malicious");
					updatedStat = updatedStat.Replace("MaliciousMalicious", "Malicious");
					if (updatedStat.Contains(mainProcessName))
					{
						MatchCollection mainP = Regex.Matches(updatedStat, "^System");
						foreach (Match k in mainP)
						{
							updatedStat = Regex.Replace(updatedStat, "^System", "MaliciousSystem");
						}
					}

					// If the malicious attacker receives a message (?), then add "x{var = msg}->"
					if (updatedStat.Contains("?") || updatedStat.Contains("!")){						
					    updatedStat = updatedStat.Replace(" ", string.Empty);
						//MaliciousSD_DeviceDiscovery()=
						string[] splitByProcName = updatedStat.Split(new string[] { ")=" }, StringSplitOptions.None);
						//MaliciousCP_SendSearchLightRequest(hash_x)= 

						if (splitByProcName.Length > 1)
						{
							string processName = splitByProcName[0];
							string[] parts = splitByProcName[1].Split(new string[] { "->" }, StringSplitOptions.None);

							foreach (string p in parts)
							{								
								if (p.Contains("?")|| p.Contains("!"))
								{
									string[] removedchannel = null;
																		   
									if (p.Contains("?"))
									{
										removedchannel = p.Split('?');//pEdited2[1].Split('?');
									}
									else if (p.Contains("!"))
									{
										removedchannel = p.Split('!');//pEdited2[1].Split('?');
									}

									string updatedPart = "";
									
									if (removedchannel[1].Contains('['))
									{
										//if contin within[] available, remove them
										Console.WriteLine("Contains [ .....");
										// TODO..............................
										Console.WriteLine(removedchannel[1]);
									}
									else
									{
										//and then split the second item by "."
										string[] msgList = removedchannel[1].Split('.');
										//homeWifiSSID.homeWifiBSSID.frequency.signalLevel.wpaAuth7.wpaCipher4

										int i = 0;
										foreach (string msg in msgList)
										{							
											//////////////////////// Generate VAR and STATUS UPDATE CSP CODE//////
											//////////////////////////////////////////////////////////////////////
											// define a unique name for the att variable
											string uniquName = "";
											MatchCollection sd = Regex.Matches(processName, "^MaliciousSD");
											MatchCollection cp = Regex.Matches(processName, "^MaliciousCP");
											MatchCollection zf = Regex.Matches(processName, "^MaliciousZFE");
											MatchCollection hs = Regex.Matches(processName, "^MaliciousHS");
											MatchCollection gs = Regex.Matches(processName, "^MaliciousGS");

											if (sd.Count > 0)
											{
												uniquName = "sd";
											}
											else if (cp.Count > 0)
											{
												uniquName = "cp";
											}
											else if (gs.Count > 0)
											{
												uniquName = "gs";
											}
											else if (zf.Count > 0)
											{
												uniquName = "zfe";
											}
											else if (hs.Count > 0)
											{
												uniquName = "hs";
											}
											//identify the var for the msg

											string varName = "";

											if (p.Contains("?")) {
												varName = "att" + uniquName +"recv"+ msg.Trim().ToLowerInvariant();
											} else if (p.Contains("!")) {
												varName = "att" + uniquName + "send" + msg.Trim().ToLowerInvariant();
											}

											
											string newVar = "var " + varName + " = -1;";
											// Add to the List<> variablListForFullModelAttackers  if new variables defined in the process
											if (!variablListForFullModelAttackers.Contains(newVar))
											{
												variablListForFullModelAttackers.Add(newVar);
											}
											//add new part to the line ("->x{var = msg}")

											updatedPart = updatedPart + "-> " + "generatedStatUpdate" + i + "{" + varName + "=" + msg + "}";
											///////////////////////////////////////////////////////////////////////////
											///////////////////////////////////////////////////////////////////////////

											/////////////////////////////// ASSERTIONS ////////////////////////////////
											///////////////////////////////////////////////////////////////////////////
											//Add assertion to the List<> securityPropertyListForFullModelAttackers
											string definitionName = "";

											if (p.Contains("?"))
											{
												definitionName = uniquName + "received" + msg.Trim();
											}
											else if (p.Contains("!"))
											{
												definitionName = uniquName + "sent" + msg.Trim();
											}

											string definition = "#define " + definitionName + " " + varName + "> -1;";
											if (!securityPropertyListForFullModelAttackers.Contains(definition))
											{
												securityPropertyListForFullModelAttackers.Add(definition);
											}

											//Add assertion to the List<> assertionListForFullModelAttackers
											foreach (string pro in attackProcesses)
											{
												MatchCollection sdN = Regex.Matches(processName, "^MaliciousSD");
												MatchCollection cpN = Regex.Matches(processName, "^MaliciousCP");
												MatchCollection zfN = Regex.Matches(processName, "^MaliciousZFE");
												MatchCollection hsN = Regex.Matches(processName, "^MaliciousHS");
												MatchCollection gsN = Regex.Matches(processName, "^MaliciousGS");

												MatchCollection sdP = Regex.Matches(pro, "^MaliciousSD");
												MatchCollection cpP = Regex.Matches(pro, "^MaliciousCP");
												MatchCollection zfP = Regex.Matches(pro, "^MaliciousZFE");
												MatchCollection hsP = Regex.Matches(pro, "^MaliciousHS");
												MatchCollection gsP = Regex.Matches(pro, "^MaliciousGS");
												string assertProcName = "";
												if (sdN.Count > 0 && sdP.Count > 0)
												{
													assertProcName = pro.Split('=')[0];
												}
												else if (cpN.Count > 0 && cpP.Count > 0)
												{
													assertProcName = pro.Split('=')[0];
												}
												else if (gsN.Count > 0 && gsP.Count > 0)
												{
													assertProcName = pro.Split('=')[0];
												}
												else if (zfN.Count > 0 && zfP.Count > 0)
												{
													assertProcName = pro.Split('=')[0];
												}
												else if (hsN.Count > 0 && hsP.Count > 0)
												{
													assertProcName = pro.Split('=')[0];
												}
												if (!assertProcName.Equals(""))
												{
													string assertion = "#assert " + assertProcName + " reaches " + definitionName + ";";
													if (!assertionListForFullModelAttackers.Contains(assertion))
													{
														assertionListForFullModelAttackers.Add(assertion);
													}
												}

											}
											/////////////////////////////////////////////////////////////////////////
											/////////////////////////////////////////////////////////////////////////
											i++;
										}
									}
									updatedStat = updatedStat.Replace(" ", string.Empty);
									string updatedJointPart = p + updatedPart;//pEdited2[1] + updatedPart;
									updatedStat = updatedStat.Replace(p, updatedJointPart);//updatedStat.Replace(pEdited2[1], updatedJointPart);
								}
							}
						}
					}
					newfullModelLines.Add(updatedStat);
				}
			}
		
			////////////////////////////////
			//////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////
			netAttackerModelLines.Add("var<Knowledge> " + ATTACKER_KNOWLEDGE_VARIABLE_NAME + ";");

			List<string> channelAttTexts = new List<string>();
			List<string> resendAttTexts = new List<string>();

			foreach (var channel in channels)
			{
				Console.WriteLine("TEST CPSModel.cs...full model !!!!!! " + channel);
				string addNewMessage = "";
				string messages = "";

				// first find the max no of messages in a line of benign processes
				int maxNo = maxMessageInOneLine;
				for (int j = 1; j <= maxNo; j++)
				{
					for (int i = 1; i <= j; i++)
					{
						if (i == j)
						{
							messages = messages + "msg" + i + "->";
						}
						else if (i < maxNo)
						{
							messages = messages + "msg" + i + ".";
						}
						addNewMessage = addNewMessage + "addKnwlge{" + ATTACKER_KNOWLEDGE_VARIABLE_NAME + ".addKnowledge(msg" + i + ")}->";
					}
					channelAttTexts.Add(channel + "?" + messages + addNewMessage + ATTACKER_PROCESS);
					messages = "";
					addNewMessage = "";
				}

				foreach (var ints in intMessages)
				{
					string msg = ints.Trim();
					////////////////////// ADD STATUS UPDATE /////////////////////////////
					string varName = "netAttsend" + msg.Trim().ToLowerInvariant(); 					
					string newVar = "var " + varName + " = -1;";
					// Add to the List<> variablListForFullModelAttackers  if new variables defined in the process
					if (!variablListForFullModelAttackers.Contains(newVar))
					{
						variablListForFullModelAttackers.Add(newVar);
					}
					//add new part to the line ("->x{var = msg}")
					msg = msg + "-> " + "generatedStatUpdate{" + varName + "=" + msg + "}";

					///////////////////////UPDATE ATTACKER ///////////////////////////////
					resendAttTexts.Add("           []if (" + ATTACKER_KNOWLEDGE_VARIABLE_NAME + ".knows(" + ints.Trim() + ")==true){" + channel + "!" + msg + "->" + ATTACKER_PROCESS + "}else{" + ATTACKER_PROCESS + "}");

					///////////////// ADD ASSERTIONS ////////////////////////////////////
					msg = ints.Trim();
					string definitionName = "netAttsent" + msg.Trim();

					string definition = "#define " + definitionName + " " + varName + "> -1;";
					if (!securityPropertyListForFullModelAttackers.Contains(definition))
					{
						securityPropertyListForFullModelAttackers.Add(definition);
					}
					string assertion = "#assert " + mainProcessName + " reaches " + definitionName + ";";
					if (!assertionListForFullModelAttackers.Contains(assertion))
					{
						assertionListForFullModelAttackers.Add(assertion);
					}
				}
				foreach (var msg in constantMessages)
				{
					Console.WriteLine("TEST CPSModel.cs...ToFullModel() constantMessages!!!!!! " + msg);
					resendAttTexts.Add("           []if (" + ATTACKER_KNOWLEDGE_VARIABLE_NAME + ".knows(" + msg.Trim() + ")==true){" + channel + "!" + msg.Trim() + "->" + ATTACKER_PROCESS + "}else{" + ATTACKER_PROCESS + "}");
				}
				foreach (var msg in allMessages)
				{
					Console.WriteLine("TEST CPSModel.cs...ToFullModel()allMessages  !!!!!! " + msg);
					resendAttTexts.Add("           []if (" + ATTACKER_KNOWLEDGE_VARIABLE_NAME + ".knows(" + msg.Trim() + ")==true){" + channel + "!" + msg.Trim() + "->" + ATTACKER_PROCESS + "}else{" + ATTACKER_PROCESS + "}");
				}
				}

			if (channelAttTexts.Count > 0)
			{
				netAttackerModelLines.Add(ATTACKER_PROCESS + "= " + channelAttTexts[0]);

				for (int i = 1; i < channelAttTexts.Count; i++)
					netAttackerModelLines.Add("           []" + channelAttTexts[i]);

				netAttackerModelLines.AddRange(resendAttTexts);

				string last = netAttackerModelLines.Last();
				if (!last.EndsWith(";"))
				{
					last += ";";
					netAttackerModelLines.RemoveAt(netAttackerModelLines.Count - 1);
					netAttackerModelLines.Add(last);
				}
			}
			fullModelLines.AddRange(variablListForFullModelAttackers); // attackers var list
			fullModelLines.AddRange(newfullModelLines); //simpleModelLines
			fullModelLines.AddRange(attackProcesses);
			fullModelLines.AddRange(securityPropertyListForFullModelAttackers);
			fullModelLines.AddRange(assertionListForFullModelAttackers);
			fullModelLines.AddRange(netAttackerModelLines);
			File.WriteAllLines(fullModelPath, fullModelLines);
			return true;
			/////////////// END  ToFullModel()
		}

		public void Verify()
		{
			try
			{
				ModuleFacadeBase modulebase = PAT.Common.Ultility.Ultility.LoadModule("CSP");
				SpecificationBase Spec = modulebase.ParseSpecification(File.ReadAllText(fullModelPath), "", fullModelPath);
				string resultMsg = "";
				foreach (var assertion in Spec.AssertionDatabase.Values)
				{
					Console.WriteLine("Verifying the assertion: " + assertion.ToString());
					// Apply verification settings
					assertion.UIInitialize(null, 0, 0);
					//Start the verification
					assertion.InternalStart();
					if (assertion.VerificationOutput.VerificationResult.Equals(VerificationResultType.INVALID))
					{
						resultMsg += "The assertion is invalid: " + assertion.ToString() + "\n";

						if (assertion.VerificationOutput.CounterExampleTrace != null)
						{
							if (assertion.VerificationOutput.CounterExampleTrace.Count > 0)
							{
								//Get the counterexample trace
								resultMsg += "Counter Example Trace: ";
								foreach (ConfigurationBase step in assertion.VerificationOutput.CounterExampleTrace)
								{
									resultMsg += "->" + step.GetDisplayEvent();
								}
								resultMsg += "\n";
							}
						}
					}
					else if (assertion.VerificationOutput.VerificationResult.Equals(VerificationResultType.VALID))
						resultMsg += "The assertion is valid: " + assertion.ToString() + "\n";
					else
						resultMsg += "The assertion could not be verified: " + assertion.ToString() + "\n";
					resultMsg += "\n";
				}
				System.Windows.MessageBox.Show(resultMsg, "Refinement and Verification Completed!");
			}
			catch (RuntimeException ex)
			{
				string runtimeErrMsg = "Runtime exception occurred: " + ex.Message + "\n";
				//Out of memory Exception
				if (ex is OutOfMemoryException)
				{
					runtimeErrMsg += "Model is too big, out of memory.";
				}
				else
				{
					runtimeErrMsg += "Check your input model for the possiblity of errors.";
				}
				System.Windows.MessageBox.Show(runtimeErrMsg);
			}
			//General Exceptions
			catch (Exception ex)
			{
				System.Windows.MessageBox.Show("Error occurred: " + ex.Message);
			}
		}
	}

	// Proxy class to get unitype typelist
	public class GetTypeListProxy : MarshalByRefObject
	{
		public HashSet<string> GetUnitypeTypeList(string assemblyPath)
		{

			Console.WriteLine("TEST CPSModel.cs... GetUnitypeTypeList !!!!!! " + assemblyPath);
			HashSet<string> typeList = new HashSet<string>(new string[] { "Unitype", "Key", "Bitstring" });//"Key",
			try
			{
				Assembly myAssembly = Assembly.LoadFile(assemblyPath);
				foreach (Type t in myAssembly.GetTypes())
				{
					if (typeList.Contains(t.BaseType.Name.Split(new string[] { "." }, StringSplitOptions.RemoveEmptyEntries).Last()))
						typeList.Add(t.Name.Split(new string[] { "." }, StringSplitOptions.RemoveEmptyEntries).Last());
				}
				return typeList;
			}
			catch (Exception)
			{
				return typeList;
			}
		}
	}
}
